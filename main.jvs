class Board {
    char[][] board;
}

class Player {
    String name;
    char mark;
}

/**
 * Fonction qui créer le plateau de jeu et l'initialise
 *
 * @return tableau à 2 dimensions
 */
Board createBoard() {
    Board board = new Board();
    board.board = new char[11][11];

    for (int i = 0; i < board.board.length; i++) {
        for (int j = 0; j < board.board[i].length; j++) {
            board.board[i][j] = '-';
        }
    }
    return board;
}

/**
 * Procédure permettant de remplir le plateau à la position x, y du joueur player.
 *
 * @param board tableau de char contenant les mouvements des joueurs
 * @param x entier représentant la colonne du tableau
 * @param y entier représentant la ligne du tableau
 * @param player instance du joueur
 */
void fillBoard(char[][] board, int x, int y, Player player) {

    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[i].length; j++) {
            if (i == x && j == y) {
                board[y][x] = player.mark;
            }
        }
    }
}

boolean isFreePos(Board b, int x, int y) {
    return !(b.board[y][x] == 'y' || b.board[y][x] == 'x');
}

void drawTopBoard() {
    print("   ");
    for (int i = 0; i < 11; i++) {
        print(i);
        print(" ");
    }
    println("");
}

void drawBottomBoard() {
    print("               _ _ _ _ _ _ _ _ _ _ _ ");
}

/**
 * Procédure permettant l'affichage central du plateau.
 *
 * @param board plateau de char contenant les mouvements des joueurs
 */
void drawMidBoard(char[][] board) {
    for (int i = 0; i < board.length; i++) {

        String space = "";
        for (int k = 0; k < i; k++) {
            space += " ";
        }
        print((i < 10) ? " " + space + i + " " : space + i + " ");

        for (int j = 0; j < board[i].length; j++) {
            print(board[i][j]);
            print(" ");
        }
        println("");
    }
}

/**
 * Procédure qui utilise chacune des 3 fonctions d'affichage du plateau
 *
 * @param board plateau de char contenant les mouvements des joueurs
 */
void drawBoard(char[][] board) {
    drawTopBoard();
    drawMidBoard(board);
}

/* ##################################### Moteur du jeu ##################################### */

boolean interval(int x, int a, int b) {
    return x >= a && x < b;
}

/**
 * Fonction permettant de compter le nombre de voisins de la case au rang pos
 *
 * @param board plateau de char contenant les mouvements des joueurs
 * @param p instance du joueur
 * @param pos tableau d'entiers de taille 2 représentant la position centrale (x,y)
 * @return le nombre de voisins
 */
int nbrVoisins(Board board, Player p, int[] pos) {
    int res = 0;

    for (int y = pos[1] - 1; y <= pos[1] + 1; y++) {
        for (int x = pos[0] - 1; x <= pos[0] + 1; x++) {
            if (!(x == pos[0] - 1 && y == pos[1] - 1
                    || x == pos[0] + 1 && y == pos[1] + 1
                    || x == pos[0] && y == pos[1])) {
                if (interval(x, 0, board.board.length) && interval(y, 0, board.board.length)) {
                    if (board.board[y][x] == p.mark) {
                        res++;
                    }
                }
            }
        }
    }
    return res;
}

/**
 * Fonction permettant d'obtenir un tableau à deux dimensions représentant les coordonnées (x,
 * y) des voisins
 *
 * @param board plateau de char contenant les mouvements des joueurs
 * @param p instance du joueur
 * @param pos tableau d'entiers de taille 2 représentant la position centrale (x,y)
 * @return tableau d'entiers à 2 dimensions.
 */
int[][] checkVoisin(Board board, Player p, int[] pos) {

    int[][] voisins = new int[nbrVoisins(board, p, pos)][2];
    int cursor = 0;

    for (int y = pos[1] - 1; y <= pos[1] + 1; y++) {
        for (int x = pos[0] - 1; x <= pos[0] + 1; x++) {
            if (!(x == pos[0] - 1 && y == pos[1] - 1
                    || x == pos[0] + 1 && y == pos[1] + 1
                    || x == pos[0] && y == pos[1])) {
                if (interval(x, 0, board.board.length) && interval(y, 0, board.board.length)) {
                    if (board.board[y][x] == p.mark) {
                        int[] coordonees = {x, y};
                        voisins[cursor] = coordonees;
                        cursor++;
                    }
                }
            }
        }
    }
    return voisins;
}

/**
 * Fonction qui vérifie si un joueur forme une ligne continue à travers le plateau
 *
 * @param board plateau de jeu
 * @param p instance du joueur
 * @param visited tableau booléen permettant de marquer les cases déjà visitées
 * @param start position initiale
 */
boolean isConnected(Board board, Player p, Boolean[][] visited, int[] start) {
    // On marque comme visitée la position actuelle
    visited[start[0]][start[1]] = true;

    if ((p.mark == 'y') ? start[1] == 10 : start[0] == 10) {
        // Condition d'arrêt
        return true;
    } else {
        int[][] voisins = checkVoisin(board, p, start);

        if (voisins.length > 2) {
            // S'il y a un 'noeud'
            boolean[] tab = new boolean[voisins.length];
            for (int i = 0; i < tab.length; i++) {
                if (!visited[voisins[i][0]][voisins[i][1]]) {
                    tab[i] = isConnected(board, p, visited, voisins[i]);
                    if (tab[i]) return true;
                }
            }
        } else {
            for (int y = 0; y < voisins.length; y++) {
                if (!visited[voisins[y][0]][voisins[y][1]]) {
                    // Si la case ne l'est pas déjà on la marque cette comme 'visitée'
                    // println(voisins[y][0] + ", " + voisins[y][1]);
                    visited[voisins[y][0]][voisins[y][1]] = true;
                    return isConnected(board, p, visited, voisins[y]);
                }
            }
        }
        return false;
    }
}

/**
 * Fonction permettant de compter le nombre de début de chemin sur le plateau selon le joueur p
 *
 * @param b instance du plateau de jeu
 * @param p instance du joueur p
 * @return nombre de début de chemin
 */
int countStartingPath(Board b, Player p) {
    int count = 0;

    if (p.mark == 'y') {
        for (int i = 0; i < b.board.length; i++) {
            if (b.board[0][i] == p.mark) count++;
        }
    } else {
        for (int i = 0; i < b.board.length; i++) {
            if (b.board[i][0] == p.mark) count++;
        }
    }

    return count;
}

int[][] getStartPos(Board b, Player p) {
    int[][] startPos = new int[countStartingPath(b, p)][2];
    int cursor = 0;

    if (p.mark == 'y') {
        for (int i = 0; i < b.board.length; i++) {
            if (b.board[0][i] == p.mark) {
                int[] coord = {i, 0};
                startPos[cursor] = coord;
                cursor++;
            }
        }
    } else {
        for (int i = 0; i < b.board.length; i++) {
            if (b.board[i][0] == p.mark) {
                int[] coord = {0, i};
                startPos[cursor] = coord;
                cursor++;
            }
        }
    }
    return startPos;
}

/**
 * Fonction permettant de créer un tableau booléen rempli de false
 *
 * @return tableau 2D de false
 */
Boolean[][] initBoolArray() {
    Boolean[][] visited = new Boolean[11][11];

    for (int i = 0; i < 11; i++) {
        for (int j = 0; j < 11; j++) {
            visited[i][j] = false;
        }
    }
    return visited;
}

boolean checkWin(Board b, Player p) {

    int[][] startPos = getStartPos(b, p);

    for (int i = 0; i < startPos.length; i++) {
        if (isConnected(b, p, initBoolArray(), startPos[0])) return true;
    }

    return false;
}

/** ######################### Menus et interactions utilisateur ######################### */
String saisie() {
    Boolean saisie = true;
    String gameMode = readString("Choix du mode de jeu ( human / ai ): ");

    while (saisie) {
        if (gameMode.equals("human") || gameMode.equals("ai")) {
            saisie = false;
        } else {
            gameMode = readString("Erreur de saisie, choix du mode de jeu ( human / ai ): ");
        }
    }
    return gameMode;
}

Player newPlayer(char mark) {
    final Player P = new Player();

    P.name = (mark == 'y') ? readString("Nom du joueur 1: ") : readString("Nom du joueur 2: ");
    P.mark = mark;

    return P;
}

int[] isLegal(Board b, Player p) {

    boolean saisie = true;
    int x = readInteger(p.name + " entrez votre coup sur l'axe X:");
    int y = readInteger(p.name + " entrez votre coup sur l'axe Y:");

    while (saisie) {

        if ((interval(x, 0, 11) && interval(y, 0, 11)) && isFreePos(b, x, y)) {
            saisie = false;
        } else {
            x = readInteger("Erreur de saisie, " + p.name + " entrez votre coup sur l'axe X:");
            y = readInteger("Erreur de saisie, " + p.name + " entrez votre coup sur l'axe X:");
        }
    }

    int[] coord = {x, y};
    return coord;
}

void humanVSHuman(Board b) {

    final Player P1 = newPlayer('y');
    final Player P2 = newPlayer('x');

    int tour = 0;
    Boolean gameRunning = true;

    drawBoard(b.board);

    while (gameRunning) {
        if (tour == 0) {
            int[] move = isLegal(b, P1);
            int x = move[0];
            int y = move[1];

            fillBoard(b.board, x, y, P1);

            tour = 1 - tour;
            clear();
            drawBoard(b.board);
            gameRunning = !(checkWin(b, P1));
        } else {

            int[] move = isLegal(b, P2);
            int x = move[0];
            int y = move[1];

            fillBoard(b.board, x, y, P2);

            tour = 1 - tour;
            clear();
            drawBoard(b.board);
            gameRunning = !(checkWin(b, P2));
        }
    }
}

void humanVSAi(Board b) {
    final Player P1 = newPlayer('y');
    final Player AI = new Player();

    AI.name = "CPU";
    AI.mark = 'x';

    int tour = 0;
    Boolean gameRunning = true;

    drawBoard(b.board);

    while (gameRunning) {
        if (tour == 0) {
            int[] move = isLegal(b, P1);
            int x = move[0];
            int y = move[1];

            fillBoard(b.board, x, y, P1);

            tour = 1 - tour;
            clear();
            drawBoard(b.board);
            gameRunning = !(checkWin(b, P1));
        } else {

            int[] move = randomMove(b);
            int x = move[0];
            int y = move[1];

            fillBoard(b.board, x, y, AI);

            tour = 1 - tour;
            clear();
            drawBoard(b.board);
            gameRunning = !(checkWin(b, AI));
        }
    }
}

/** ####################### AI ####################### */
int[] randomMove(Board b) {
    int x = random(0, 11);
    int y = random(0, 11);

    while (!isFreePos(b, x, y)) {
        x = random(0, 11);
        y = random(0, 11);
    }

    int[] res = {x, y};
    return res;
}

void main() {

    Board b = createBoard();
    String gameMode = saisie();

    if (gameMode.equals("human")) {
        // Jeu humain VS humain
        humanVSHuman(b);

    } else {
        // Jeu humain VS AI
        humanVSAi(b);
    }
}
